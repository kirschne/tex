\section{Implementation}\label{sec:impl}

\todo{.}Klar machen, welche Plugins ich verwendet habe! Liste.\todo{.}

As described in chapter \ref{sec:s2e}, working with \sse can be divided into a code selection and the actual analysis part.

In the \textbf{code selection phase} \sse is configured to focus on the program \app in user space only.
The whole environment will be treated as a black box.
% Possible calls into the kernel are assumed to work correctly.
Symbolic execution will only be applied inside the code of \app.

The next step is to precisely specify which variables shall be treated symbolically.
In general, as a start we want to make all user inputs symbolic.
For a closed source binary this can be done in several ways.
A command line tool can be called from a wrapper program which hands over symbolic arguments instead of concrete ones.
If user input is entered in a UI, a further code into the assembly code is necessary in order to find the memory locations where the corresponding variables are written.\todo{..}
%look for ... calls...
\sse can intercept execution of the specified memory addresses and replace them with symbolic values (state:writeMemorySymb(\ldots)).\todo{con?}
% consistency models?????

KLEE, the engine for symbolic execution, also requires some configuration.
As path search strategy this analysis uses a depth first search.
\todo{..}

\bigskip

Most logic in the \textbf{analysis part} relies on \sse's \textit{Annotations} plugin.
It allows fine monitoring and even fiddling with the execution state by annotating single instructions or functions in the program binary.

For the scenario in this paper all instructions which handle connections to the internet are of particular interest.
The C library call \textit{connect} helps to identify where the program is connecting to, and the corresponding \textit{write} and \textit{read} calls allow to find out what data is sent and received in this connection.
Memory addresses of these relevant calls can be retrieved from the assembly code.
Since all calls concerned with connecting to the internet seem to take place in a single function named \textit{send\_data}, calls to this function as a whole shall be monitored, too.

After providing \sse's \textit{Annotations} plugin with all relevant memory addresses plus a little more configuration, we can now execute code every time the program runs into one of the interesting instructions.
At this point, we will \ldots

1.) log that instruction $X$ was reached.
Together with other \sse output this information shows which execution paths run into the \textit{send\_data} method and when they do so.

2.) save information about the executed instruction in the current plugin state.
This allows to check whether there have been prior connections to the internet when the program runs into the next annotated instruction.

3.) read out parameters of the called function.
The function \textit{send\_data}, for instance, is called with one parameter, which appears to be a memory location.
Now \sse's analysis interfaces can be employed to dynamically find out what is written in the respective memory.

4.) read (or write) registers (EAX, ESP, ...).
... Check out call conventions of write, ...
%This may either be used to check the current internal state, or...

5.) switch variables (memory locations) from concrete to symbolic mode (or vice versa).
... Nice for controlling consistency models. Not used currently.


Figure \ref{} shows relevant parts of the assembly code. Figure \ref{} presents excerpts from the resulting analysis plugin.

\bigskip

In addition to the \textit{Annotations} plugin, analysis in this paper also employs the \textit{TestCaseGenerator}.
For each execution path, it finds concrete inputs for all symbolic variables.
Those will be printed upon termination of the path and, apart from helping to understand the program, may serve as input for further testing.



\iffalse
ยง5 	Implementation (of the test case using S2E)
		> Vorgehen
		> Verwendete Konsistenzmodelle
		> Arbeitsweise von Selektoren/Analysatoren
\fi